.. raw:: pdf

    PageBreak

=========
Tutorial
=========
This tutorial will show you the use of MuPDF in Python step by step.

Because MuPDF supports not only PDF, but also XPS, OpenXPS and EPUB formats, so does PyMuPDF. Nevertheless we will only talk about PDF's for the sake of brevity.

As for string handling, MuPDF will pass back any string as UTF-8 encoded - no exceptions. Where this binding has added functionality, we usually decode string to unicode. An example is the :meth:`Document.ToC` method.

Import the Bindings
==========================
The Python bindings to MuPDF are made available by this import statement:
::
 import fitz


Open a Document
======================
In order to access a supported document, it must be opened with the following statement:
::
 doc = fitz.Document(filename)

This will create ``doc`` as a :ref:`Document` object. ``filename`` must be a Python string or unicode object that specifies the name of an existing file (with or without a fully or partially qualified path). A :ref:`Document` contains several attributes and functions. Among them are meta information (like "author" or "subject"), number of total pages, outline and encryption information.

Some :ref:`Document` methods and attributes
=============================================

=========================== ==========================================
**Method / Attribute**      **Description**
=========================== ==========================================
:attr:`Document.pageCount`  Number of pages of ``filename`` (integer).
:attr:`Document.metadata`   Metadata of the ``Document`` (dictionary).
:attr:`Document.outline`    First outline entry of ``Document``
:meth:`Document.ToC`        Table of contents of ``Document`` (list).
:meth:`Document.loadPage`   Create a ``Page`` object.
=========================== ==========================================

Access Meta Data
========================
:ref:`Document`.metadata is a Python dictionary with the following keys. For details of their meanings and formats consult the PDF manuals, e.g. `Adobe PDF Reference sixth edition 1.7 November 2006 <http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf>`_. Some details can also be found in the chapter for :ref:`Document`. The meta data fields are of type string if not otherwise indicated and may be missing, in which case they contain ``None``.

======================== ==============================
**Key**                  **Value**
======================== ==============================
.. data:: producer       Producer (producing software)
.. data:: format         PDF format, e.g. 'PDF 1.4'
.. data:: encryption     Encryption method used
.. data:: author         Author
.. data:: modDate        Date of last modification
.. data:: keywords       Keywords (dictionary)
.. data:: title          Title
.. data:: creationDate   Date of creation
.. data:: creator        Creating application
.. data:: subject        Subject
======================== ==============================

Work with Outlines
=========================
Entering the documents outline tree works like this:
::
 olItem = doc.outline    # the document's first outline item

This creates olItem as an :ref:`Outline` object.

Some :ref:`Outline` methods and attributes
===================================================

============================ =================================================
**Method / Attribute**       **Description**
============================ =================================================
:meth:`Outline.saveText`     Save table of contents as a text file
:meth:`Outline.saveXML`      Save table of contents as a quasi-XML file
:attr:`Outline.next`         Next item of the same level
:attr:`Outline.down`         Next item one level down
:attr:`Outline.title`        Title of this item (UTF-8)
:attr:`Outline.dest`         Destination ('where does this entry point to?')
============================ =================================================

Some :attr:`Outline.dest` attributes
=====================================

=========================== ========================================
**Attribute**               **Description**
=========================== ========================================
:attr:`Outline.dest.page`   Target page number
:attr:`Outline.dest.lt`     Top-left corner of target rectangle
:attr:`Outline.dest.rb`     Bottem-right corner of target rectangle
=========================== ========================================

MuPDF also supports outline destinations to other files and to URIs. See :ref:`Outline`.

In order to get a document's table of contents as a Python list, use the following function:
::
 toc = doc.ToC()       # [[level, title, page], ...], or []


Work with Pages
======================
Tasks that can be performed with a :ref:`Page` are at the core of MuPDF's functionality.
Among other things, you can render a :ref:`Page`, optionally zooming, rotating or shearing it.
You can write it's image to files (in PNG format), extract text from it or perform searches for text elements.
At first, a page object must be created:
::
 page = doc.loadPage(n)        # represents page n of the document

Here are some typical uses of :ref:`Page` objects:

Inspect the links on a :ref:`Page`
------------------------------------
Here is an example that displays all links and their types:
::
 #-----------------------------------------------------------------------------------
 # Get all links of the current page
 #-----------------------------------------------------------------------------------
 ln = page.loadLinks()
 #-----------------------------------------------------------------------------------
 # Links are organized as a single linked list. We need to check each occurrence
 # to see what info we can get
 #-----------------------------------------------------------------------------------
 while ln:
     if ln.dest.kind == fitz.LINK_URI:
	     print '[LINK]URI: %s' % ln.dest.uri
     elif ln.dest.kind == fitz.LINK_GOTO:
         print '[LINK]jump to page %d' % ln.dest.page
     else:
         pass
     ln = ln.next

Render a :ref:`Page`
-----------------------
This example creates an image out a page's content:
::
 #-----------------------------------------------------------------------------------
 # Get the page's rectangle
 #-----------------------------------------------------------------------------------
 rect = page.bound()
 #-----------------------------------------------------------------------------------
 # create the smallest pixel area containing the rectangle
 #-----------------------------------------------------------------------------------
 irect = rect.round()
 #-----------------------------------------------------------------------------------
 # create an empty RGBA pixel map of the pixel area's size
 #-----------------------------------------------------------------------------------
 pix = fitz.Pixmap(fitz.Colorspace(fitz.CS_RGB), irect)
 pix.clearWith(255)             # Initialize with color "white" and "no transparency"
 dev = fitz.Device(pix)         # Create a draw device for the pixel map
 page.run(dev, fitz.Identity)   # finally render the page with no changes
 #-----------------------------------------------------------------------------------
 # now pix contains an image of the page, ready to be used
 #-----------------------------------------------------------------------------------

Save the page image in a file
-----------------------------------
We can simply store the image in a PNG file:
::
 pix.writePNG("test.png")


Use the image in a dialog manager
-----------------------------------
Or we convert the image into a bitmap usable by a dialog manager:
::
 data = pix.samples                   # data = bytearray of raw pixel data (RGBA)
 bitmap = wx.BitmapFromBufferRGBA(irect.width,
             irect.height, str(data)) # wxPython only accepts strings, no bytearrays



Extract and search for text of a :ref:`Page`
---------------------------------------------
We can also extract all text of a page in a big chunk of string:
::
 dl = fitz.DisplayList()                  # create a DisplayList
 ts = fitz.TextSheet()                    # create a TextSheet
 tp = fitz.TextPage()                     # create a TextPage
 dev = fitz.Device(ts, tp)                # create a text Device
 # now run the page through the created device
 dl.run(dev, fitz.Identity, irect)
 # Extract the complete text of the page now contained in the TextPage.
 # Includes all whitespace (tabulation, end-of-line, etc.) characters, too.
 text = tp.extractText()                  # remember: UTF-8 encoding!

If you want more details, you can determine exactly where on a page a certain string appears:
::
 # search for at most 4 page locations with specific contents
 res = tp.search('MuPDF', 4)

The result ``res`` will now be ``[]`` or a list of no more than 4 :ref:`IRect` rectangles that contain the string 'MuPDF'. The ``maxhit`` parameter (in our case set to 4) is optional defaulting to 16.

Output
=======
Output capabilities of MuPDF (like PDF generation or the like) are currently very limited. Some code exists to save PDF documents with only a subset of pages, cleaned up and / or decrypted.

As mentioned above, we support a method :meth:`Document.save`. This function creates a copy of the input document. If we have successfully decrypted the document before, this outcome will be a decrypted version. In addition, this method will perform a clean-up: if the input containes invalid / broken cross references, the saved version will have them corrected, such that it is usually readable by other Python PDF software, like PyPDF2. In many cases, the saved version will also be smaller than the original.

MuPDF's standalone utility ``mutool`` offers a ``clean`` option, which does the same thing, but offers more compression / decompession options. We are considering to support this in our binding as well.

Close
======
In some situations it may be desirable to "close" a :ref:`Document` such that it becomes again fully available to other tasks / the operating system. This can be achieved by the :meth:`Document.close` method.

After invoking it, **all** objects created in relation to the underlying file (:ref:`Document`, :ref:`Pixmap`, :ref:`Page`, etc.) will be invalid  and may no longer be used - or really bad things will happen.

Re-opening the same file by creating another :ref:`Document` is, however, no problem. As an illustration of possibilities, here a sequence of statements that could be used
::
 doc = fitz.Document(f) # open a document
 ... other statements   # like decryption
 doc.save(fnew)         # save it decrypted / cleaned up
 doc.close()            # close input file
 os.remove(f)           # remove it
 os.rename(fnew, f)     # rename the cleaned / decrypted version
 doc = fitz.Document(f) # use it as input for MuPDF





