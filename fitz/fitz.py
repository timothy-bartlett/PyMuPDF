# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_fitz')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_fitz')
    _fitz = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_fitz', [dirname(__file__)])
        except ImportError:
            import _fitz
            return _fitz
        if fp is not None:
            try:
                _mod = imp.load_module('_fitz', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _fitz = swig_import_helper()
    del swig_import_helper
else:
    import _fitz
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

VersionFitz = "1.10a"
VersionBind = '1.10.0'
VersionDate = '2016-12-04 13:26:13'

LINK_NONE   = 0
LINK_GOTO   = 1
LINK_URI    = 2
LINK_LAUNCH = 3
LINK_NAMED  = 4
LINK_GOTOR  = 5
LINK_FLAG_L_VALID = 1
LINK_FLAG_T_VALID = 2
LINK_FLAG_R_VALID = 4
LINK_FLAG_B_VALID = 8
LINK_FLAG_FIT_H = 16
LINK_FLAG_FIT_V = 32
LINK_FLAG_R_IS_ZOOM = 64

class linkDest():
    '''link or outline destination details'''
    def __init__(self, obj):
        self.dest = ""
        self.fileSpec = ""
        self.flags = 0
        self.isMap = False
        self.isUri = False
        self.kind = LINK_NONE
        self.lt = Point(0, 0)
        self.named = ""
        self.newWindow = ""
        self.page = obj.page
        self.rb = Point(0, 0)
        self.uri = obj.uri
        if obj.isExternal:
            self.page = -1
            self.kind = LINK_URI
        if not self.uri:
            self.page = -1
            self.kind = LINK_NONE
        if not obj.isExternal and self.uri:
            if self.uri.startswith("#"):
                self.named = ""
                self.kind = LINK_GOTO
                ftab = self.uri[1:].split(",")
                if len(ftab) == 3:
                    self.page = int(ftab[0]) - 1
                    self.lt = Point(float(ftab[1]), float(ftab[2]))
                    self.flags = self.flags | LINK_FLAG_L_VALID | LINK_FLAG_T_VALID
                else:
                    try:
                        self.page = int(ftab[0]) - 1
                    except:
                        self.kind = LINK_NAMED
                        self.named = self.uri
            else:
                self.kind = LINK_NAMED
                self.named = self.uri
        if obj.isExternal:
            if self.uri.startswith(("http://", "https://", "mailto:", "ftp://")):
                self.isUri = True
                self.kind = LINK_URI
            elif self.uri.startswith("file://"):
                self.fileSpec = self.uri[7:]
                ftab = self.fileSpec.split("#")
                self.isUri = False
                self.kind = LINK_LAUNCH
                if len(ftab) == 2:
                    if ftab[1].startswith("page="):
                        self.page = int(ftab[1][5:]) - 1
                        self.kind = LINK_GOTOR
                        self.isUri = False
                        self.fileSpec = ftab[0]
                    else:
                        self.page = -1
                        self.kind = LINK_LAUNCH
                        self.isUri = True
            else:
                self.isUri = True
                self.kind = LINK_LAUNCH


class Document(_object):
    """Proxy of C fz_document_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Document, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Document, name)
    __repr__ = _swig_repr

    def __init__(self, filename=None, stream=None):
        """__init__(fz_document_s self, char const * filename=None, PyObject * stream=None) -> Document"""

        if not filename or type(filename) == str:
            pass
        elif type(filename) == unicode:
            filename = filename.encode('utf8')
        else:
            raise TypeError("if specified, filename must be a string.")
        self.name = filename if filename else ""
        self.streamlen = len(stream) if stream else 0
        if stream and not filename:
            raise ValueError("filetype missing with stream specified")
        self.isClosed    = 0
        self.isEncrypted = 0
        self.metadata    = None
        self.openErrCode = 0
        self.openErrMsg  = ''



        this = _fitz.new_Document(filename, stream)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        if this:
            self.openErrCode = self._getGCTXerrcode()
            self.openErrMsg  = self._getGCTXerrmsg()
        if this and self.needsPass:
            self.isEncrypted = 1
        # we won't init encrypted doc until it is decrypted
        if this and not self.needsPass:
            self.initData()
            self.thisown = False




    def close(self):
        """close(Document self)"""

        if self.isClosed:
            raise ValueError("operation illegal for closed doc")
        if hasattr(self, '_outline') and self._outline:
            self._dropOutline(self._outline)
            self._outline = None
        self.metadata    = None
        self.isClosed    = 1
        self.openErrCode = 0
        self.openErrMsg  = ''


        return _fitz.Document_close(self)


    def loadPage(self, number):
        """loadPage(Document self, int number) -> Page"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Document_loadPage(self, number)

        if val:
            val.thisown = True
            val.parent = self
            pageCount = self.pageCount
            n = number
            while n < 0: n += pageCount
            val.number = n


        return val


    def _loadOutline(self):
        """_loadOutline(Document self) -> Outline"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__loadOutline(self)


    def _dropOutline(self, ol):
        """_dropOutline(Document self, Outline ol)"""
        return _fitz.Document__dropOutline(self, ol)

    @property

    def pageCount(self):
        """pageCount(Document self) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_pageCount(self)


    def _getMetadata(self, key):
        """_getMetadata(Document self, char const * key) -> char *"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__getMetadata(self, key)

    @property

    def needsPass(self):
        """needsPass(Document self) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_needsPass(self)


    def _getGCTXerrcode(self):
        """_getGCTXerrcode(Document self) -> int"""
        return _fitz.Document__getGCTXerrcode(self)


    def _getGCTXerrmsg(self):
        """_getGCTXerrmsg(Document self) -> char *"""
        return _fitz.Document__getGCTXerrmsg(self)


    def authenticate(self, arg2):
        """authenticate(Document self, char const * arg2) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Document_authenticate(self, arg2)

        if val: # the doc is decrypted successfully and we init the outline
            self.isEncrypted = 0
            self.initData()


        return val


    def save(self, filename, garbage=0, clean=0, deflate=0, incremental=0, ascii=0, expand=0, linear=0):
        """save(Document self, char * filename, int garbage=0, int clean=0, int deflate=0, int incremental=0, int ascii=0, int expand=0, int linear=0) -> int"""

        if self.isClosed:
            raise ValueError("operation illegal for closed doc")
        if type(filename) == str:
            pass
        elif type(filename) == unicode:
            filename = filename.encode('utf8')
        else:
            raise TypeError("filename must be a string")
        if filename == self.name and not incremental:
            raise ValueError("save to original requires incremental")
        if incremental and (self.name != filename or self.streamlen > 0):
            raise ValueError("incremental save to original file only")


        return _fitz.Document_save(self, filename, garbage, clean, deflate, incremental, ascii, expand, linear)


    def write(self, garbage=0, clean=0, deflate=0, ascii=0, expand=0, linear=0):
        """write(Document self, int garbage=0, int clean=0, int deflate=0, int ascii=0, int expand=0, int linear=0) -> PyObject *"""

        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_write(self, garbage, clean, deflate, ascii, expand, linear)


    def insertPDF(self, docsrc, from_page=-1, to_page=-1, start_at=-1, rotate=-1, links=1):
        """
        insertPDF(PDFsrc, from_page, to_page, start_at, rotate, links) -> int
        Insert page range [from, to] of source PDF, starting as page number start_at.
        """

        if self.isClosed:
            raise ValueError("operation illegal for closed doc")
        sa = start_at
        if sa < 0:
            sa = self.pageCount

        val = _fitz.Document_insertPDF(self, docsrc, from_page, to_page, start_at, rotate, links)

        if links:
            self._do_links(docsrc, from_page = from_page, to_page = to_page,
                           start_at = sa)

        return val


    def deletePage(self, pno):
        """deletePage(Document self, int pno) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_deletePage(self, pno)


    def deletePageRange(self, from_page=-1, to_page=-1):
        """deletePageRange(Document self, int from_page=-1, int to_page=-1) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_deletePageRange(self, from_page, to_page)


    def copyPage(self, pno, to=-1):
        """copyPage(Document self, int pno, int to=-1) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_copyPage(self, pno, to)


    def movePage(self, pno, to=-1):
        """movePage(Document self, int pno, int to=-1) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_movePage(self, pno, to)


    def select(self, pyliste):
        """select(list) -> int; build sub-pdf with pages in list"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Document_select(self, pyliste)

        self.initData()


        return val


    def _readPageText(self, pno, output=0):
        """_readPageText(Document self, int pno, int output=0) -> char *"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__readPageText(self, pno, output)

    @property

    def permissions(self):
        """permissions -> dictionary containing permissions"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_permissions(self)


    def _getPageObjNumber(self, pno):
        """_getPageObjNumber(Document self, int pno) -> PyObject *"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__getPageObjNumber(self, pno)


    def getPageImageList(self, pno):
        """getPageImageList(Document self, int pno) -> PyObject *"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_getPageImageList(self, pno)


    def getPageFontList(self, pno):
        """getPageFontList(Document self, int pno) -> PyObject *"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document_getPageFontList(self, pno)


    def _delToC(self):
        """_delToC(Document self) -> PyObject *"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Document__delToC(self)

        self.initData()


        return val


    def _getOLRootNumber(self):
        """_getOLRootNumber(Document self) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__getOLRootNumber(self)


    def _getNewXref(self):
        """_getNewXref(Document self) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__getNewXref(self)


    def _getXrefLength(self):
        """_getXrefLength(Document self) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__getXrefLength(self)


    def _getObjectString(self, xnum):
        """_getObjectString(Document self, int xnum) -> char const *"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__getObjectString(self, xnum)


    def _updateObject(self, xref, text):
        """_updateObject(Document self, int xref, char * text) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__updateObject(self, xref, text)


    def _setMetadata(self, text):
        """_setMetadata(Document self, char * text) -> int"""
        if self.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Document__setMetadata(self, text)


    def initData(self):
        if self.isEncrypted:
            raise ValueError("cannot initData - document still encrypted")
        self._outline = self._loadOutline()
        self.metadata = dict([(k,self._getMetadata(v)) for k,v in {'format':'format', 'title':'info:Title', 'author':'info:Author','subject':'info:Subject', 'keywords':'info:Keywords','creator':'info:Creator', 'producer':'info:Producer', 'creationDate':'info:CreationDate', 'modDate':'info:ModDate'}.items()])
        self.metadata['encryption'] = None if self._getMetadata('encryption')=='None' else self._getMetadata('encryption')

    outline = property(lambda self: self._outline)

    def saveIncr(self):
        """ Save PDF incrementally"""
        return self.save(self.name, incremental = True)

    def __repr__(self):
        if self.streamlen == 0:
            return "fitz.Document('%s')" % (self.name,)
        return "fitz.Document('%s', bytearray)" % (self.name,)

    def __getitem__(self, i):
        return self.loadPage(i)

    def __len__(self):
        return self.pageCount

    __swig_destroy__ = _fitz.delete_Document
    __del__ = lambda self: None
Document_swigregister = _fitz.Document_swigregister
Document_swigregister(Document)

class Page(_object):
    """Proxy of C fz_page_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Page, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Page, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _fitz.delete_Page
    __del__ = lambda self: None

    def bound(self):
        """bound(Page self) -> Rect"""
        if self.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Page_bound(self)

        if val:
            val.thisown = True


        return val

    rect = property(bound, doc="Rect (mediabox) of the page")

    def run(self, dw, m):
        """run(Page self, Device dw, Matrix m) -> int"""
        if self.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Page_run(self, dw, m)


    def loadLinks(self):
        """loadLinks(Page self) -> Link"""
        if self.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Page_loadLinks(self)

        if val:
            val.thisown = True


        return val

    firstLink = property(loadLinks)
    @property

    def firstAnnot(self):
        """firstAnnot(Page self) -> Annot"""
        if self.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Page_firstAnnot(self)
        if val:
            val.thisown = True
            val.parent = self # owning page object

        return val


    def deleteAnnot(self, fannot):
        """deleteAnnot(Page self, Annot fannot) -> Annot"""
        if self.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Page_deleteAnnot(self, fannot)
        if val:
            val.thisown = True
            val.parent = self # owning page object

        return val


    def createAnnot(self, type, rect, width=1):
        """createAnnot(Page self, int type, Rect rect, float width=1) -> Annot"""
        if self.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Page_createAnnot(self, type, rect, width)

    @property

    def rotation(self):
        """rotation(Page self) -> int"""
        if self.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Page_rotation(self)


    def setRotation(self, rot):
        """setRotation(Page self, int rot) -> int"""
        if self.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Page_setRotation(self, rot)


    def _readPageText(self, output=0):
        """_readPageText(Page self, int output=0) -> char *"""
        return _fitz.Page__readPageText(self, output)


    def __str__(self):
        return "page %s of %s" % (self.number, repr(self.parent))
    def __repr__(self):
        return repr(self.parent) + "[" + str(self.number) + "]"

Page_swigregister = _fitz.Page_swigregister
Page_swigregister(Page)


def _fz_transform_rect(rect, transform):
    """_fz_transform_rect(Rect rect, Matrix transform) -> Rect"""
    return _fitz._fz_transform_rect(rect, transform)
class Rect(_object):
    """Proxy of C fz_rect_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rect, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rect, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x0"] = _fitz.Rect_x0_set
    __swig_getmethods__["x0"] = _fitz.Rect_x0_get
    if _newclass:
        x0 = _swig_property(_fitz.Rect_x0_get, _fitz.Rect_x0_set)
    __swig_setmethods__["y0"] = _fitz.Rect_y0_set
    __swig_getmethods__["y0"] = _fitz.Rect_y0_get
    if _newclass:
        y0 = _swig_property(_fitz.Rect_y0_get, _fitz.Rect_y0_set)
    __swig_setmethods__["x1"] = _fitz.Rect_x1_set
    __swig_getmethods__["x1"] = _fitz.Rect_x1_get
    if _newclass:
        x1 = _swig_property(_fitz.Rect_x1_get, _fitz.Rect_x1_set)
    __swig_setmethods__["y1"] = _fitz.Rect_y1_set
    __swig_getmethods__["y1"] = _fitz.Rect_y1_get
    if _newclass:
        y1 = _swig_property(_fitz.Rect_y1_get, _fitz.Rect_y1_set)

    def __init__(self, *args):
        """
        __init__(fz_rect_s self) -> Rect
        __init__(fz_rect_s self, Rect s) -> Rect
        __init__(fz_rect_s self, Point lt, Point rb) -> Rect
        __init__(fz_rect_s self, float x0, float y0, Point rb) -> Rect
        __init__(fz_rect_s self, Point lt, float x1, float y1) -> Rect
        __init__(fz_rect_s self, float x0, float y0, float x1, float y1) -> Rect
        """
        this = _fitz.new_Rect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _fitz.delete_Rect
    __del__ = lambda self: None

    def round(self):
        """round(Rect self) -> IRect"""
        val = _fitz.Rect_round(self)

        val.thisown = True


        return val


    def includePoint(self, p):
        """includePoint(Rect self, Point p) -> Rect"""
        return _fitz.Rect_includePoint(self, p)


    def intersect(self, r):
        """intersect(Rect self, Rect r) -> Rect"""
        return _fitz.Rect_intersect(self, r)


    def includeRect(self, r):
        """includeRect(Rect self, Rect r) -> Rect"""
        return _fitz.Rect_includeRect(self, r)


    def transform(self, m):
        _fitz._fz_transform_rect(self, m)
        return self

    def __getitem__(self, i):
        a = [self.x0, self.y0, self.x1, self.y1]
        return a[i]

    def __setitem__(self, i, v):
        if   i == 0: self.x0 = v
        elif i == 1: self.y0 = v
        elif i == 2: self.x1 = v
        elif i == 3: self.y1 = v
        else:
            raise IndexError("list index out of range")
        return

    def __len__(self):
        return 4

    def __repr__(self):
        return "fitz.Rect" + str((self.x0, self.y0, self.x1, self.y1))

    width = property(lambda self: self.x1-self.x0)
    height = property(lambda self: self.y1-self.y0)

Rect_swigregister = _fitz.Rect_swigregister
Rect_swigregister(Rect)

class IRect(_object):
    """Proxy of C fz_irect_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IRect, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IRect, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x0"] = _fitz.IRect_x0_set
    __swig_getmethods__["x0"] = _fitz.IRect_x0_get
    if _newclass:
        x0 = _swig_property(_fitz.IRect_x0_get, _fitz.IRect_x0_set)
    __swig_setmethods__["y0"] = _fitz.IRect_y0_set
    __swig_getmethods__["y0"] = _fitz.IRect_y0_get
    if _newclass:
        y0 = _swig_property(_fitz.IRect_y0_get, _fitz.IRect_y0_set)
    __swig_setmethods__["x1"] = _fitz.IRect_x1_set
    __swig_getmethods__["x1"] = _fitz.IRect_x1_get
    if _newclass:
        x1 = _swig_property(_fitz.IRect_x1_get, _fitz.IRect_x1_set)
    __swig_setmethods__["y1"] = _fitz.IRect_y1_set
    __swig_getmethods__["y1"] = _fitz.IRect_y1_get
    if _newclass:
        y1 = _swig_property(_fitz.IRect_y1_get, _fitz.IRect_y1_set)
    __swig_destroy__ = _fitz.delete_IRect
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(fz_irect_s self) -> IRect
        __init__(fz_irect_s self, IRect s) -> IRect
        __init__(fz_irect_s self, int x0, int y0, int x1, int y1) -> IRect
        """
        this = _fitz.new_IRect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def translate(self, xoff, yoff):
        """translate(IRect self, int xoff, int yoff) -> IRect"""
        return _fitz.IRect_translate(self, xoff, yoff)


    def intersect(self, ir):
        """intersect(IRect self, IRect ir) -> IRect"""
        return _fitz.IRect_intersect(self, ir)


    width = property(lambda self: self.x1-self.x0)
    height = property(lambda self: self.y1-self.y0)

    def getRect(self):
        return Rect(self.x0, self.y0, self.x1, self.y1)

    def __getitem__(self, i):
        a = [self.x0, self.y0, self.x1, self.y1]
        return a[i]

    def __setitem__(self, i, v):
        if   i == 0: self.x0 = v
        elif i == 1: self.y0 = v
        elif i == 2: self.x1 = v
        elif i == 3: self.y1 = v
        else:
            raise IndexError("list index out of range")
        return

    def __len__(self):
        return 4

    def __repr__(self):
        return "fitz.IRect" + str((self.x0, self.y0, self.x1, self.y1))

IRect_swigregister = _fitz.IRect_swigregister
IRect_swigregister(IRect)

class Pixmap(_object):
    """Proxy of C fz_pixmap_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pixmap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pixmap, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _fitz.Pixmap_x_set
    __swig_getmethods__["x"] = _fitz.Pixmap_x_get
    if _newclass:
        x = _swig_property(_fitz.Pixmap_x_get, _fitz.Pixmap_x_set)
    __swig_setmethods__["y"] = _fitz.Pixmap_y_set
    __swig_getmethods__["y"] = _fitz.Pixmap_y_get
    if _newclass:
        y = _swig_property(_fitz.Pixmap_y_get, _fitz.Pixmap_y_set)
    __swig_setmethods__["w"] = _fitz.Pixmap_w_set
    __swig_getmethods__["w"] = _fitz.Pixmap_w_get
    if _newclass:
        w = _swig_property(_fitz.Pixmap_w_get, _fitz.Pixmap_w_set)
    __swig_setmethods__["h"] = _fitz.Pixmap_h_set
    __swig_getmethods__["h"] = _fitz.Pixmap_h_get
    if _newclass:
        h = _swig_property(_fitz.Pixmap_h_get, _fitz.Pixmap_h_set)
    __swig_setmethods__["n"] = _fitz.Pixmap_n_set
    __swig_getmethods__["n"] = _fitz.Pixmap_n_get
    if _newclass:
        n = _swig_property(_fitz.Pixmap_n_get, _fitz.Pixmap_n_set)
    __swig_setmethods__["interpolate"] = _fitz.Pixmap_interpolate_set
    __swig_getmethods__["interpolate"] = _fitz.Pixmap_interpolate_get
    if _newclass:
        interpolate = _swig_property(_fitz.Pixmap_interpolate_get, _fitz.Pixmap_interpolate_set)
    __swig_setmethods__["xres"] = _fitz.Pixmap_xres_set
    __swig_getmethods__["xres"] = _fitz.Pixmap_xres_get
    if _newclass:
        xres = _swig_property(_fitz.Pixmap_xres_get, _fitz.Pixmap_xres_set)
    __swig_setmethods__["yres"] = _fitz.Pixmap_yres_set
    __swig_getmethods__["yres"] = _fitz.Pixmap_yres_get
    if _newclass:
        yres = _swig_property(_fitz.Pixmap_yres_get, _fitz.Pixmap_yres_set)

    def __init__(self, *args):
        """
        __init__(fz_pixmap_s self, Colorspace cs, IRect bbox, int alpha=0) -> Pixmap
        __init__(fz_pixmap_s self, Colorspace cs, Pixmap spix) -> Pixmap
        __init__(fz_pixmap_s self, Colorspace cs, int w, int h, PyObject * samples, int alpha=0) -> Pixmap
        __init__(fz_pixmap_s self, char * filename) -> Pixmap
        __init__(fz_pixmap_s self, PyObject * imagedata) -> Pixmap
        __init__(fz_pixmap_s self, Document doc, int xref) -> Pixmap
        """
        this = _fitz.new_Pixmap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _fitz.delete_Pixmap
    __del__ = lambda self: None

    def gammaWith(self, gamma):
        """gammaWith(Pixmap self, float gamma)"""
        return _fitz.Pixmap_gammaWith(self, gamma)


    def tintWith(self, red, green, blue):
        """tintWith(Pixmap self, int red, int green, int blue)"""

                    # only GRAY and RGB pixmaps allowed
        if self.n not in (2, 4):
            raise TypeError("only gray and rgb pixmaps can be tinted")


        return _fitz.Pixmap_tintWith(self, red, green, blue)


    def clearWith(self, *args):
        """
        clearWith(Pixmap self, int value)
        clearWith(Pixmap self, int value, IRect bbox)
        """
        return _fitz.Pixmap_clearWith(self, *args)


    def copyPixmap(self, src, bbox):
        """copyPixmap(Pixmap self, Pixmap src, IRect bbox)"""
        return _fitz.Pixmap_copyPixmap(self, src, bbox)

    @property

    def stride(self):
        """stride(Pixmap self) -> int"""
        return _fitz.Pixmap_stride(self)

    @property

    def alpha(self):
        """alpha(Pixmap self) -> int"""
        return _fitz.Pixmap_alpha(self)

    @property

    def colorspace(self):
        """colorspace(Pixmap self) -> Colorspace"""
        return _fitz.Pixmap_colorspace(self)

    @property

    def irect(self):
        """irect(Pixmap self) -> IRect"""
        return _fitz.Pixmap_irect(self)

    @property

    def size(self):
        """size(Pixmap self) -> int"""
        return _fitz.Pixmap_size(self)


    def writePNG(self, filename, savealpha=-1):
        """writePNG(Pixmap self, char * filename, int savealpha=-1) -> int"""

        if type(filename) == str:
            pass
        elif type(filename) == unicode:
            filename = filename.encode('utf8')
        else:
            raise TypeError("filename must be a string")
        if not filename.lower().endswith(".png"):
            raise ValueError("filename must end with '.png'")


        return _fitz.Pixmap_writePNG(self, filename, savealpha)


    def getPNGData(self, savealpha=-1):
        """getPNGData(Pixmap self, int savealpha=-1) -> PyObject *"""
        return _fitz.Pixmap_getPNGData(self, savealpha)


    def _writeIMG(self, filename, format, savealpha=-1):
        """_writeIMG(Pixmap self, char * filename, int format, int savealpha=-1) -> int"""

        if type(filename) == str:
            pass
        elif type(filename) == unicode:
            filename = filename.encode('utf8')
        else:
            raise TypeError("filename must be a string")


        return _fitz.Pixmap__writeIMG(self, filename, format, savealpha)


    def invertIRect(self, *args):
        """
        invertIRect(Pixmap self)
        invertIRect(Pixmap self, IRect irect)
        """
        return _fitz.Pixmap_invertIRect(self, *args)


    def samples(self):
        """samples(Pixmap self) -> PyObject *"""
        return _fitz.Pixmap_samples(self)


    samples = property(samples)
    width  = w
    height = h

    def __len__(self):
        return self.size

    def __repr__(self):
        return "fitz.Pixmap(%s, %s, %s)" % (self.colorspace, self.irect, self.alpha)
Pixmap_swigregister = _fitz.Pixmap_swigregister
Pixmap_swigregister(Pixmap)

CS_RGB = _fitz.CS_RGB
CS_GRAY = _fitz.CS_GRAY
CS_CMYK = _fitz.CS_CMYK
class Colorspace(_object):
    """Proxy of C fz_colorspace_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Colorspace, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Colorspace, name)
    __repr__ = _swig_repr

    def __init__(self, type):
        """__init__(fz_colorspace_s self, int type) -> Colorspace"""
        this = _fitz.new_Colorspace(type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    @property

    def n(self):
        """n(Colorspace self) -> int"""
        return _fitz.Colorspace_n(self)

    @property

    def name(self):
        """name(Colorspace self) -> char *"""
        return _fitz.Colorspace_name(self)

    __swig_destroy__ = _fitz.delete_Colorspace
    __del__ = lambda self: None
Colorspace_swigregister = _fitz.Colorspace_swigregister
Colorspace_swigregister(Colorspace)

class Device(_object):
    """Proxy of C DeviceWrapper struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Device, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Device, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(DeviceWrapper self, Pixmap pm, IRect clip) -> Device
        __init__(DeviceWrapper self, DisplayList dl) -> Device
        __init__(DeviceWrapper self, TextSheet ts, TextPage tp) -> Device
        """
        this = _fitz.new_Device(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _fitz.delete_Device
    __del__ = lambda self: None
Device_swigregister = _fitz.Device_swigregister
Device_swigregister(Device)


def _fz_pre_scale(m, sx, sy):
    """_fz_pre_scale(Matrix m, float sx, float sy) -> Matrix"""
    return _fitz._fz_pre_scale(m, sx, sy)

def _fz_pre_shear(m, sx, sy):
    """_fz_pre_shear(Matrix m, float sx, float sy) -> Matrix"""
    return _fitz._fz_pre_shear(m, sx, sy)

def _fz_pre_rotate(m, degree):
    """_fz_pre_rotate(Matrix m, float degree) -> Matrix"""
    return _fitz._fz_pre_rotate(m, degree)
class Matrix(_object):
    """Proxy of C fz_matrix_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a"] = _fitz.Matrix_a_set
    __swig_getmethods__["a"] = _fitz.Matrix_a_get
    if _newclass:
        a = _swig_property(_fitz.Matrix_a_get, _fitz.Matrix_a_set)
    __swig_setmethods__["b"] = _fitz.Matrix_b_set
    __swig_getmethods__["b"] = _fitz.Matrix_b_get
    if _newclass:
        b = _swig_property(_fitz.Matrix_b_get, _fitz.Matrix_b_set)
    __swig_setmethods__["c"] = _fitz.Matrix_c_set
    __swig_getmethods__["c"] = _fitz.Matrix_c_get
    if _newclass:
        c = _swig_property(_fitz.Matrix_c_get, _fitz.Matrix_c_set)
    __swig_setmethods__["d"] = _fitz.Matrix_d_set
    __swig_getmethods__["d"] = _fitz.Matrix_d_get
    if _newclass:
        d = _swig_property(_fitz.Matrix_d_get, _fitz.Matrix_d_set)
    __swig_setmethods__["e"] = _fitz.Matrix_e_set
    __swig_getmethods__["e"] = _fitz.Matrix_e_get
    if _newclass:
        e = _swig_property(_fitz.Matrix_e_get, _fitz.Matrix_e_set)
    __swig_setmethods__["f"] = _fitz.Matrix_f_set
    __swig_getmethods__["f"] = _fitz.Matrix_f_get
    if _newclass:
        f = _swig_property(_fitz.Matrix_f_get, _fitz.Matrix_f_set)
    __swig_destroy__ = _fitz.delete_Matrix
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(fz_matrix_s self) -> Matrix
        __init__(fz_matrix_s self, Matrix n) -> Matrix
        __init__(fz_matrix_s self, float sx, float sy, int shear=0) -> Matrix
        __init__(fz_matrix_s self, float degree) -> Matrix
        """
        this = _fitz.new_Matrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def invert(self, m):
        """invert(Matrix self, Matrix m) -> int"""
        return _fitz.Matrix_invert(self, m)


    def preTranslate(self, sx, sy):
        """preTranslate(Matrix self, float sx, float sy) -> Matrix"""
        return _fitz.Matrix_preTranslate(self, sx, sy)


    def concat(self, m1, m2):
        """concat(Matrix self, Matrix m1, Matrix m2) -> Matrix"""
        return _fitz.Matrix_concat(self, m1, m2)


    def preScale(self, sx, sy):
        """preScale(Matrix self, float sx, float sy) -> Matrix self updated"""
        _fitz._fz_pre_scale(self, sx, sy)
        return self
    def preShear(self, sx, sy):
        """preShear(Matrix self, float sx, float sy) -> Matrix self updated"""
        _fitz._fz_pre_shear(self, sx, sy)
        return self
    def preRotate(self, degree):
        """preRotate(Matrix self, float degree) -> Matrix self updated"""
        _fitz._fz_pre_rotate(self, degree)
        return self
    def __getitem__(self, i):
        m = [self.a, self.b, self.c, self.d, self.e, self.f]
        return m[i]

    def __setitem__(self, i, v):
        if   i == 0: self.a = v
        elif i == 1: self.b = v
        elif i == 2: self.c = v
        elif i == 3: self.d = v
        elif i == 4: self.e = v
        elif i == 5: self.f = v
        else:
            raise IndexError("list index out of range")
        return

    def __len__(self):
        return 6
    def __repr__(self):
        return "fitz.Matrix(%s, %s, %s, %s, %s, %s)" % (self.a, self.b, self.c, self.d, self.e, self.f)

Matrix_swigregister = _fitz.Matrix_swigregister
Matrix_swigregister(Matrix)

class Outline(_object):
    """Proxy of C fz_outline_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Outline, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Outline, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_getmethods__["title"] = _fitz.Outline_title_get
    if _newclass:
        title = _swig_property(_fitz.Outline_title_get)
    __swig_getmethods__["page"] = _fitz.Outline_page_get
    if _newclass:
        page = _swig_property(_fitz.Outline_page_get)
    __swig_getmethods__["next"] = _fitz.Outline_next_get
    if _newclass:
        next = _swig_property(_fitz.Outline_next_get)
    __swig_getmethods__["down"] = _fitz.Outline_down_get
    if _newclass:
        down = _swig_property(_fitz.Outline_down_get)
    __swig_getmethods__["is_open"] = _fitz.Outline_is_open_get
    if _newclass:
        is_open = _swig_property(_fitz.Outline_is_open_get)

    def saveXML(self, filename):
        """saveXML(Outline self, char const * filename) -> int"""

        if type(filename) == str:
            pass
        elif type(filename) == unicode:
            filename = filename.encode('utf8')
        else:
            raise TypeError("filename must be a string")


        return _fitz.Outline_saveXML(self, filename)


    def saveText(self, filename):
        """saveText(Outline self, char const * filename) -> int"""

        if type(filename) == str:
            pass
        elif type(filename) == unicode:
            filename = filename.encode('utf8')
        else:
            raise TypeError("filename must be a string")


        return _fitz.Outline_saveText(self, filename)

    @property

    def uri(self):
        """uri(Outline self) -> char *"""
        return _fitz.Outline_uri(self)

    @property

    def isExternal(self):
        """isExternal(Outline self) -> int"""
        return _fitz.Outline_isExternal(self)

    isOpen = is_open

    @property
    def dest(self):
        '''outline destination details'''
        return linkDest(self)

    __swig_destroy__ = _fitz.delete_Outline
    __del__ = lambda self: None
Outline_swigregister = _fitz.Outline_swigregister
Outline_swigregister(Outline)


def _fz_transform_point(point, transform):
    """_fz_transform_point(Point point, Matrix transform) -> Point"""
    return _fitz._fz_transform_point(point, transform)
class Point(_object):
    """Proxy of C fz_point_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Point, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _fitz.Point_x_set
    __swig_getmethods__["x"] = _fitz.Point_x_get
    if _newclass:
        x = _swig_property(_fitz.Point_x_get, _fitz.Point_x_set)
    __swig_setmethods__["y"] = _fitz.Point_y_set
    __swig_getmethods__["y"] = _fitz.Point_y_get
    if _newclass:
        y = _swig_property(_fitz.Point_y_get, _fitz.Point_y_set)
    __swig_destroy__ = _fitz.delete_Point
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(fz_point_s self) -> Point
        __init__(fz_point_s self, Point q) -> Point
        __init__(fz_point_s self, float x, float y) -> Point
        """
        this = _fitz.new_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def transform(self, m):
        _fitz._fz_transform_point(self, m)
        return self

    def __getitem__(self, i):
        a = [self.x, self.y]
        return a[i]

    def __len__(self):
        return 2

    def __repr__(self):
        return "fitz.Point" + str((self.x, self.y))

Point_swigregister = _fitz.Point_swigregister
Point_swigregister(Point)

ANNOT_TEXT = _fitz.ANNOT_TEXT
ANNOT_LINK = _fitz.ANNOT_LINK
ANNOT_FREETEXT = _fitz.ANNOT_FREETEXT
ANNOT_LINE = _fitz.ANNOT_LINE
ANNOT_SQUARE = _fitz.ANNOT_SQUARE
ANNOT_CIRCLE = _fitz.ANNOT_CIRCLE
ANNOT_POLYGON = _fitz.ANNOT_POLYGON
ANNOT_POLYLINE = _fitz.ANNOT_POLYLINE
ANNOT_HIGHLIGHT = _fitz.ANNOT_HIGHLIGHT
ANNOT_UNDERLINE = _fitz.ANNOT_UNDERLINE
ANNOT_SQUIGGLY = _fitz.ANNOT_SQUIGGLY
ANNOT_STRIKEOUT = _fitz.ANNOT_STRIKEOUT
ANNOT_STAMP = _fitz.ANNOT_STAMP
ANNOT_CARET = _fitz.ANNOT_CARET
ANNOT_INK = _fitz.ANNOT_INK
ANNOT_POPUP = _fitz.ANNOT_POPUP
ANNOT_FILEATTACHMENT = _fitz.ANNOT_FILEATTACHMENT
ANNOT_SOUND = _fitz.ANNOT_SOUND
ANNOT_MOVIE = _fitz.ANNOT_MOVIE
ANNOT_WIDGET = _fitz.ANNOT_WIDGET
ANNOT_SCREEN = _fitz.ANNOT_SCREEN
ANNOT_PRINTERMARK = _fitz.ANNOT_PRINTERMARK
ANNOT_TRAPNET = _fitz.ANNOT_TRAPNET
ANNOT_WATERMARK = _fitz.ANNOT_WATERMARK
ANNOT_3D = _fitz.ANNOT_3D
ANNOT_XF_Invisible = _fitz.ANNOT_XF_Invisible
ANNOT_XF_Hidden = _fitz.ANNOT_XF_Hidden
ANNOT_XF_Print = _fitz.ANNOT_XF_Print
ANNOT_XF_NoZoom = _fitz.ANNOT_XF_NoZoom
ANNOT_XF_NoRotate = _fitz.ANNOT_XF_NoRotate
ANNOT_XF_NoView = _fitz.ANNOT_XF_NoView
ANNOT_XF_ReadOnly = _fitz.ANNOT_XF_ReadOnly
ANNOT_XF_Locked = _fitz.ANNOT_XF_Locked
ANNOT_XF_ToggleNoView = _fitz.ANNOT_XF_ToggleNoView
ANNOT_XF_LockedContents = _fitz.ANNOT_XF_LockedContents
ANNOT_LE_None = _fitz.ANNOT_LE_None
ANNOT_LE_Square = _fitz.ANNOT_LE_Square
ANNOT_LE_Circle = _fitz.ANNOT_LE_Circle
ANNOT_LE_Diamond = _fitz.ANNOT_LE_Diamond
ANNOT_LE_OpenArrow = _fitz.ANNOT_LE_OpenArrow
ANNOT_LE_ClosedArrow = _fitz.ANNOT_LE_ClosedArrow
ANNOT_LE_Butt = _fitz.ANNOT_LE_Butt
ANNOT_LE_ROpenArrow = _fitz.ANNOT_LE_ROpenArrow
ANNOT_LE_RClosedArrow = _fitz.ANNOT_LE_RClosedArrow
ANNOT_LE_Slash = _fitz.ANNOT_LE_Slash
class Annot(_object):
    """Proxy of C fz_annot_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Annot, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Annot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _fitz.delete_Annot
    __del__ = lambda self: None
    @property

    def rect(self):
        """rect(Annot self) -> Rect"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_rect(self)


    def setRect(self, r):
        """setRect(Annot self, Rect r)"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_setRect(self, r)

    @property

    def vertices(self):
        """vertices(Annot self) -> PyObject *"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_vertices(self)

    @property

    def colors(self):
        """colors(Annot self) -> PyObject *"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_colors(self)


    def setColors(self, colors):
        """setColors(Annot self, PyObject * colors)"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_setColors(self, colors)

    @property

    def lineEnds(self):
        """lineEnds(Annot self) -> PyObject *"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_lineEnds(self)


    def setLineEnds(self, start, end):
        """setLineEnds(Annot self, int start, int end)"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_setLineEnds(self, start, end)

    @property

    def type(self):
        """type(Annot self) -> PyObject *"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_type(self)

    @property

    def info(self):
        """info(Annot self) -> PyObject *"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_info(self)


    def setInfo(self, info):
        """setInfo(Annot self, PyObject * info) -> int"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_setInfo(self, info)

    @property

    def border(self):
        """border(Annot self) -> PyObject *"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_border(self)


    def setBorder(self, width):
        """setBorder(Annot self, float width)"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_setBorder(self, width)

    @property

    def flags(self):
        """flags(Annot self) -> int"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_flags(self)


    def setFlags(self, flags):
        """setFlags(Annot self, int flags)"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_setFlags(self, flags)

    @property

    def next(self):
        """next(Annot self) -> Annot"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        val = _fitz.Annot_next(self)
        if val:
            val.thisown = True
            val.parent = self.parent # copy owning page object

        return val


    def getPixmap(self, matrix=None, colorspace=None, alpha=0):
        """getPixmap(Annot self, Matrix matrix=None, Colorspace colorspace=None, int alpha=0) -> Pixmap"""
        if self.parent.parent.isClosed:
            raise ValueError("operation illegal for closed doc")

        return _fitz.Annot_getPixmap(self, matrix, colorspace, alpha)

Annot_swigregister = _fitz.Annot_swigregister
Annot_swigregister(Annot)

class Link(_object):
    """Proxy of C fz_link_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Link, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Link, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _fitz.delete_Link
    __del__ = lambda self: None
    @property

    def uri(self):
        """uri(Link self) -> char *"""
        return _fitz.Link_uri(self)

    @property

    def isExternal(self):
        """isExternal(Link self) -> int"""
        return _fitz.Link_isExternal(self)


    page = -1
    @property
    def dest(self):
        '''link destination details'''
        return linkDest(self)

    @property

    def rect(self):
        """rect(Link self) -> Rect"""
        return _fitz.Link_rect(self)

    @property

    def next(self):
        """next(Link self) -> Link"""
        val = _fitz.Link_next(self)
        if val: val.thisown = True

        return val

Link_swigregister = _fitz.Link_swigregister
Link_swigregister(Link)

class DisplayList(_object):
    """Proxy of C fz_display_list_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DisplayList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DisplayList, name)
    __repr__ = _swig_repr

    def __init__(self, mediabox):
        """__init__(fz_display_list_s self, Rect mediabox) -> DisplayList"""
        this = _fitz.new_DisplayList(mediabox)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _fitz.delete_DisplayList
    __del__ = lambda self: None

    def run(self, dw, m, area):
        """run(DisplayList self, Device dw, Matrix m, Rect area) -> int"""
        return _fitz.DisplayList_run(self, dw, m, area)

DisplayList_swigregister = _fitz.DisplayList_swigregister
DisplayList_swigregister(DisplayList)

class TextSheet(_object):
    """Proxy of C fz_stext_sheet_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TextSheet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TextSheet, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(fz_stext_sheet_s self) -> TextSheet"""
        this = _fitz.new_TextSheet()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _fitz.delete_TextSheet
    __del__ = lambda self: None
TextSheet_swigregister = _fitz.TextSheet_swigregister
TextSheet_swigregister(TextSheet)

class TextPage(_object):
    """Proxy of C fz_stext_page_s struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TextPage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TextPage, name)
    __repr__ = _swig_repr
    __swig_setmethods__["len"] = _fitz.TextPage_len_set
    __swig_getmethods__["len"] = _fitz.TextPage_len_get
    if _newclass:
        len = _swig_property(_fitz.TextPage_len_get, _fitz.TextPage_len_set)

    def __init__(self, mediabox):
        """__init__(fz_stext_page_s self, Rect mediabox) -> TextPage"""
        this = _fitz.new_TextPage(mediabox)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _fitz.delete_TextPage
    __del__ = lambda self: None

    def search(self, needle, hit_max=16):
        """search(TextPage self, char const * needle, int hit_max=16) -> Rect"""
        return _fitz.TextPage_search(self, needle, hit_max)


    def extractText(self):
        """extractText(TextPage self) -> char const *"""
        return _fitz.TextPage_extractText(self)


    def extractXML(self):
        """extractXML(TextPage self) -> char const *"""
        return _fitz.TextPage_extractXML(self)


    def extractHTML(self):
        """extractHTML(TextPage self) -> char const *"""
        return _fitz.TextPage_extractHTML(self)


    def extractJSON(self):
        """extractJSON(TextPage self) -> char const *"""
        return _fitz.TextPage_extractJSON(self)

TextPage_swigregister = _fitz.TextPage_swigregister
TextPage_swigregister(TextPage)

# This file is compatible with both classic and new-style classes.


